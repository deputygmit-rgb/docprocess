# Embeddings & Metadata Storage - Complete Analysis

## Quick Answer

**Where are embeddings saved?**
```
Qdrant Vector Database (in-memory)
├─ 768-dimensional vectors
├─ COSINE distance metric
├─ Unique ID per chunk
└─ Payload includes metadata
```

**Where is metadata saved?**
```
SQLite Database (documents.db)
├─ Document info (filename, status, dates)
├─ layout_data (JSON) - Raw extraction
├─ graph_data (JSON) - Graph structure
├─ processed_json (JSON) - Processed output
└─ Plus: Cache layer (Redis/Memory, 2-hr TTL)
```

---

## Complete Storage Breakdown

### EMBEDDINGS

| Aspect | Details |
|--------|---------|
| **Location** | Qdrant in-memory vector database |
| **Format** | 768-dimensional float vectors |
| **Dimension** | 768 (fixed) |
| **Distance Metric** | COSINE similarity (0-1 scale) |
| **Storage Limit** | 50 chunks per document max |
| **Unique ID** | MD5(document_id + chunk_index) |
| **Generation** | generate_simple_embedding() function |
| **Algorithm** | Deterministic bag-of-words hashing |
| **Speed** | ~2ms per search query |
| **Persistence** | ❌ Temporary (in-memory, lost on restart) |

**Stored in Code:**
- Function: `qdrant_service.store_chunks()` (app/services/qdrant_service.py)
- Called from: `celery_app.py` line 283-291
- Generated by: `generate_simple_embedding()` (celery_app.py lines 52-68)

**Qdrant Collection:**
```python
Collection Name: "documents"
Vector Size: 768
Distance: COSINE
Auto-created: Yes (on first use)
```

### METADATA - QDRANT PAYLOAD

Each embedding is stored with metadata payload:

```json
{
  "point_id": "MD5_HASH",
  "vector": [0.123, 0.456, ..., 0.789],  // 768 values
  "payload": {
    "document_id": 1,
    "chunk_index": 0,
    "text": "extracted text content",
    "element_id": "e1",
    "element_type": "paragraph|table|chart",
    "page": 1
  }
}
```

**Queryable:** Yes, can filter by document_id
**Searchable:** Yes, via COSINE similarity

### METADATA - SQLITE DATABASE (PERMANENT)

#### Database Structure

**Table: documents**
```sql
documents:
├─ id (INTEGER PRIMARY KEY)
├─ filename (VARCHAR)
├─ file_type (VARCHAR)
├─ file_path (VARCHAR)
├─ file_size (INTEGER)
├─ status (ENUM: pending|processing|completed|failed)
├─ layout_data (JSON) ← Raw extraction output
├─ graph_data (JSON) ← Graph structure with nodes/edges
├─ processed_json (JSON) ← Post-processed data
├─ error_message (TEXT)
├─ created_at (DATETIME)
├─ updated_at (DATETIME)
└─ processed_at (DATETIME)
```

#### JSON Field Details

**1. layout_data**
```json
{
  "page_number": 1,
  "layout": {
    "elements": [
      {
        "id": "element_0",
        "type": "paragraph|table|chart|image",
        "text": "extracted text",
        "bbox": [x1, y1, x2, y2],
        "confidence": 0.95,
        "is_chart": false,
        "chart_details": {...},
        "table_data": {...}
      }
    ],
    "relationships": [...],
    "chart_count": 0
  },
  "chart_details": [...]
}
```
**Source:** VisionService.extract_layout()
**Size:** 10-100 KB per page
**Contains:** Raw vision API extraction

**2. graph_data**
```json
{
  "nodes": [
    {
      "id": "node_0",
      "type": "element_type",
      "text": "content",
      "page": 1,
      "bbox": [...],
      "metadata": {...},
      "embeddings": {
        "content_embedding": true,
        "context_embedding": true,
        "combined_embedding": true
      },
      "chart_details": {...}
    }
  ],
  "edges": [
    {
      "from": "n1",
      "to": "n2",
      "type": "describes|references|contains"
    }
  ],
  "node_count": 42,
  "edge_count": 38
}
```
**Source:** GraphService.build_document_graph()
**Size:** 20-200 KB
**Contains:** Graph structure with embeddings flags

**3. processed_json**
```json
{
  "elements": [
    {
      "id": "processed_0",
      "type": "paragraph|table|chart",
      "content": "formatted text",
      "metadata": {
        "page": 1,
        "bbox": [...],
        "confidence": 0.95
      },
      "relationships": [...]
    }
  ],
  "statistics": {
    "total_elements": 42,
    "by_type": {
      "paragraph": 20,
      "table": 5,
      "chart": 2
    }
  },
  "generation_time_seconds": 1.23,
  "generated_at": "2025-11-24T10:30:00Z"
}
```
**Source:** PostProcessorService.process_graph_data()
**Size:** 15-150 KB
**Contains:** User-friendly formatted output

#### Storage Characteristics

**Permanent:** ✅ Survives application restart
**File:** documents.db (SQLite)
**Size:** Grows ~450 KB per document (depends on content)
**Query:** By document_id, by status
**Index:** None on JSON fields (full table scan)

---

## CACHE LAYER

**Configuration:**
- Key Format: `document:{document_id}`
- Value: {layout_data, graph_data, processed_json}
- TTL: 7200 seconds (2 hours)
- Backend: Redis or in-memory

**Purpose:** Fast retrieval of recently accessed documents

**Speed:**
- Cache hit: ~1ms
- Cache miss: ~10ms (fetch from DB)

---

## PROCESSING PIPELINE

### Step 1: Document Upload
```
File → ./uploads/[timestamp]_filename
→ Database record created (PENDING status)
```

### Step 2: Extract Layout
```
Document file → Vision API → layout_data JSON
```
**Stored in:** Memory during processing
**Saved to:** doc.layout_data (after processing complete)

### Step 3: Build Graph
```
layout_data → Graph construction → Embeddings generated
→ graph_data JSON (includes embedding flags)
```
**Stored in:** Memory during processing
**Saved to:** doc.graph_data (after processing complete)

### Step 4: Generate Embeddings
```
For each graph node with text:
  1. Create chunk (text, element_id, element_type, page)
  2. Generate 768-dim embedding
  3. Store in list (up to 50 chunks)
```
**Stored in:** Memory during processing

### Step 5: Store Embeddings
```
chunks + embeddings → Qdrant
```
**Stored in:** Qdrant vector database
**Format:** Points with vectors + payloads
**Persistent:** ❌ No (in-memory mode)

### Step 6: Post-Process
```
graph_data → Formatted JSON → processed_json
```
**Stored in:** Memory during processing
**Saved to:** doc.processed_json

### Step 7: Database Update
```
Update document record with all metadata
+ Save to cache
```
**Stored in:** SQLite + Redis/Memory cache

---

## DATA RETRIEVAL

### Get Document with All Metadata
```python
# From API: GET /documents/{id}
document = db.query(Document).filter(Document.id == id).first()
# Returns: All fields including layout_data, graph_data, processed_json
```

### Search Embeddings
```python
# From API: POST /search
results = qdrant.search_similar(query_embedding, doc_id, limit=5)
# Returns: Top-5 chunks with scores 0.0-1.0
```

### Get from Cache
```python
# Inside application
cached = cache.get(f"document:{id}")
# Returns: {layout_data, graph_data, processed_json} or None
```

---

## SUMMARY TABLE

| Data | Location | Type | Size | Permanent | Searchable | Speed |
|------|----------|------|------|-----------|-----------|-------|
| **Embeddings** | Qdrant | 768-dim vectors | ~3 KB/chunk | ❌ | ✅ COSINE | ~2ms |
| **Chunk metadata** | Qdrant payload | JSON | ~500 B/chunk | ❌ | ✅ (doc_id) | ~2ms |
| **Document info** | SQLite | JSON | ~450 KB | ✅ | ❌ | ~5ms |
| **layout_data** | SQLite | JSON | 10-100 KB | ✅ | ❌ | ~5ms |
| **graph_data** | SQLite | JSON | 20-200 KB | ✅ | ❌ | ~5ms |
| **processed_json** | SQLite | JSON | 15-150 KB | ✅ | ❌ | ~5ms |
| **Cache** | Redis/Mem | JSON | 20-200 KB | ❌ (2hr) | ✅ | ~1ms |

---

## KEY INSIGHTS

### Embeddings (Qdrant)
✅ **Advantages:**
- Fast similarity search (~2ms)
- COSINE distance metric
- Metadata stored with vectors (payload)
- Automatic collection creation
- Good for semantic search

❌ **Limitations:**
- In-memory only (temporary)
- 50 chunks max per document
- Lost on application restart
- Not persistent to disk

### Metadata (SQLite)
✅ **Advantages:**
- Permanent storage
- Complete extraction results
- Can query by document_id
- Standard SQL database
- No external dependencies

❌ **Limitations:**
- JSON fields not indexed
- No full-text search
- Slower than cache (~5ms)

### Cache (Redis/Memory)
✅ **Advantages:**
- Very fast (~1ms)
- 2-hour TTL (good balance)
- Automatic expiration

❌ **Limitations:**
- Temporary (expires)
- Optional/graceful fallback

---

## CONFIGURATION

### Qdrant
```python
# app/core/config.py
QDRANT_HOST: "localhost"
QDRANT_PORT: 6333
QDRANT_COLLECTION: "documents"

# Actual usage (in-memory mode)
QdrantClient(":memory:")
```

### Database
```python
DATABASE_URL: "sqlite:///./documents.db"
# Can switch to PostgreSQL if needed
```

### Cache
```python
REDIS_URL: "redis://localhost:6379/0"
# Optional - falls back to memory cache
```

---

## MAKING EMBEDDINGS PERSISTENT

**Current:** In-memory (data lost on restart)
**To Make Permanent:** Switch Qdrant to server mode

**Steps:**
1. Run Qdrant server separately
2. Update app/services/qdrant_service.py:
   ```python
   # Change from:
   self.client = QdrantClient(":memory:")
   
   # To:
   self.client = QdrantClient(
       host=settings.QDRANT_HOST,
       port=settings.QDRANT_PORT,
       api_key=settings.QDRANT_API_KEY
   )
   ```
3. Configure environment variables
4. Restart application

---

## FILE LOCATIONS

| Type | Location |
|------|----------|
| **SQLite DB** | documents.db (same dir as app) |
| **Uploaded files** | ./uploads/ |
| **Qdrant** | In-memory (RAM) |
| **Cache** | Redis or memory |
| **Embeddings** | Qdrant |

---

## TYPICAL PROCESSING TIMELINE

```
Upload document
  ↓ 10ms (file save)
Extract content
  ↓ 100-500ms (API calls)
Build graph
  ↓ 50ms (graph construction)
Generate embeddings
  ↓ 100ms (50 chunks)
Store embeddings
  ↓ 50ms (Qdrant upsert)
Update database
  ↓ 10ms (SQLite commit)
Update cache
  ↓ 5ms (Redis set)
---
Total: ~500-1500ms (0.5-1.5 seconds)
```

---

## API ENDPOINTS FOR METADATA

| Endpoint | Returns |
|----------|---------|
| `GET /documents/{id}` | All metadata (layout_data, graph_data, processed_json) |
| `GET /documents` | List of documents |
| `DELETE /documents/{id}` | Delete from DB + Qdrant |

---

## DOCUMENTS CREATED

1. **EMBEDDINGS_AND_METADATA_STORAGE_MAP.md** - Comprehensive mapping
2. **STORAGE_ARCHITECTURE_DIAGRAM.md** - Visual diagrams
3. **This document** - Complete analysis

---

**Last Updated:** November 24, 2025
**Status:** Complete mapping verified
**All storage locations:** Documented and explained
